#!/usr/bin/env ruby

require 'rubygems'
require 'commander/import'

$:.unshift File.join(File.dirname(__FILE__), *%w[.. lib])
require 'pwm'

program :version, Pwm::VERSION
program :description, "#{program(:name)} is a secure password manager for the commandline"
program :help, 'Author', 'Nicholas E. Rabenau <nerab@gmx.at>'

DEFAULT_STORE_FILE = File.expand_path("~/.#{program(:name)}.pstore")

store_file = DEFAULT_STORE_FILE

global_option '-V', '--verbose', 'Enable verbose output'
global_option('-f', '--file FILE', 'Determine the file that holds the store'){|file|
  store_file = file
}
global_option '-g', '--gui', 'Request the master password using an OS-specific GUI'

command :init do |c|
  c.syntax = "#{program(:name)} init"
  c.summary = 'Initializes a new store'
  c.description = 'This command initializes a new password store. The master password will be read from STDIN. Empty passwords will not be accepted.'
  c.example "Initializes a new password store in #{DEFAULT_STORE_FILE}", "#{program(:name)} #{c.name}"
  c.example "Initializes a new password store in /tmp/crackme.txt", "#{program(:name)} #{c.name} --file /tmp/crackme.txt"
  c.option '--force', 'Force-overwrite an existing store file'
  c.action do |args, options|
    if File.exists?(store_file) && !options.force # Store checks this too, but we want to fail fast.
      raise "There already exists a store at #{store_file}. Use --force to overwrite it or pass --file to specify a different store"
    end

    begin
      begin
        master_password = get_password('Enter new master password:', options.gui)
      end while begin
        validate!(master_password) # Basic idea from http://stackoverflow.com/questions/136793/is-there-a-do-while-loop-in-ruby
      rescue StandardError => e
        puts "Error: Master password #{$!}"
        true
      end

      # Ask for password confimation if running in interactive mode (terminal)
      raise "Error: Passwords do not match" if STDIN.tty? && master_password != get_password('Enter master password again:', options.gui)

      Pwm::Store.new(store_file, master_password, {:force => options.force})
      STDERR.puts "Successfully initialized new store at #{store_file}" if options.verbose
    rescue Pwm::Dialog::Cancelled
      STDERR.puts "Aborted." if options.verbose
    end
  end
end

command :get do |c|
  c.syntax = "#{program(:name)} get KEY"
  c.summary = 'Retrieves the value for KEY and prints it to STDOUT.'
  c.description = 'This command retrieves the value stored under KEY and prints it on STDOUT.'
  c.example 'Reads the value stored under the key "foo" and prints it to STDOUT', "#{program(:name)} #{c.name} foo"
  c.action do |args, options|
    raise "Store file '#{store_file}' cannot be found" unless File.exists?(store_file) # Store checks this too, but we want to fail fast.
    raise "KEY may not be blank" if args[0].blank?

    begin
      puts Pwm::Store.open(store_file, get_password('Enter master password:', options.gui)).get(args[0])
    rescue Pwm::Dialog::Cancelled
      STDERR.puts "Aborted." if options.verbose
    end
  end
end

command :list do |c|
  c.syntax = "#{program(:name)} list [FILTER]"
  c.summary = 'Lists all keys with optional FILTER.'
  c.description = 'This command prints all keys to STDOUT. If present, only those keys matching FILTER will be returned.'
  c.example 'Prints all keys', "#{program(:name)} #{c.name}"
  c.example 'Prints all keys which start with "foo"', "#{program(:name)} #{c.name} foo"
  c.example 'Prints all keys separated by comma', "#{program(:name)} #{c.name} --separator ,"
  c.option '-s', '--separator SEPARATOR', String, 'Separate keys by SEPARATOR'
  c.action do |args, options|
    options.default :separator => ' '
    raise "Store file '#{store_file}' cannot be found" unless File.exists?(store_file) # Store checks this too, but we want to fail fast.

    begin
      puts Pwm::Store.open(store_file, get_password('Enter master password:', options.gui)).list(args[0]).join(options.separator)
    rescue Pwm::Dialog::Cancelled
      STDERR.puts "Aborted." if options.verbose
    end
  end
end

command :put do |c|
  c.syntax = "#{program(:name)} put KEY [VALUE]"
  c.summary = 'Stores VALUE under KEY'
  c.description = 'Adds or updates the entry stored under KEY. If KEY is already present in the store, it will be updated with VALUE. If KEY is not already present in the store, a new entry will be created. If VALUE is not given, it will be read from STDIN.'
  c.example 'Stores the value "bar" under the key "foo"', "#{program(:name)} #{c.name} foo bar"
  c.example 'Reads STDIN and stores that as value under the key "foo"', "#{program(:name)} #{c.name} foo"
  c.action do |args, options|
    raise "Store file '#{store_file}' cannot be found" unless File.exists?(store_file) # Store checks this too, but we want to fail fast.
    raise "KEY may not be blank" if 0 == args.size || args[0].blank?

    # Ask for the master password _before_ it may be necessary to ask for the value in a terminal
    begin
      store = Pwm::Store.open(store_file, get_password('Enter master password:', options.gui))
    rescue Pwm::Dialog::Cancelled
      STDERR.puts "Aborted." if options.verbose
      exit 1
    end

    value = args[1]

    if !value
      raise "VALUE is required" unless STDIN.tty?
      value = get_text("Enter value for key '#{args[0]}':", options.gui)
    end

    store.put(args[0], value)
    STDERR.puts "Successfully stored #{args[1]} under  #{args[0]}." if options.verbose
  end
end

def get_password(prompt, gui = false)
  (gui ? Pwm::Dialog.password_dialog.new(program(:name), prompt) : Pwm::Dialog::ConsolePasswordDialog.new(prompt)).get_input
end

def get_text(prompt, gui = false)
  (gui ? Pwm::Dialog.text_dialog.new(program(:name), prompt) : Pwm::Dialog::ConsoleTextDialog.new(prompt)).get_input
end

def validate!(pwd)
  # Validations go from simple to more complicated
  raise "may not be blank" if pwd.empty?
  raise "must have at least eight characters" if 8 > pwd.length
  raise "must contain at least one integer" unless pwd =~ /.*\d/
  raise "at least one character either (lower or upper case)" unless pwd =~ /.*([a-z]|[A-Z])/
  raise "special characters are only allowed if ASCII values 20 to 7E" unless pwd =~ /[\x20-\x7E]/
  raise "minimum length of of 8 characters" unless pwd =~ /^(?=.*\d)(?=.*([a-z]|[A-Z]))([\x20-\x7E]){8}$/
end
