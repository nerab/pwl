#!/usr/bin/env ruby

require 'rubygems'
require 'commander/import'

$:.unshift File.join(File.dirname(__FILE__), *%w[.. lib])
require 'pwm'

program :version, Pwm::VERSION
program :description, "#{program(:name)} is a secure password manager for the command line."

EXIT_CODES = {
  :success               => Pwm::Message.new('Success.'),
  :aborted               => Pwm::Message.new('Aborted by user.', 1),
  :passwords_dont_match  => Pwm::ErrorMessage.new('Passwords do not match.', 2),
  :no_value_found        => Pwm::Message.new('No value found for <%= key %>.', 3, :key => 'KEY'),
  :file_exists           => Pwm::ErrorMessage.new('There already exists a store at <%= file %>. Use --force to overwrite it or --file to specify a different store.', 4, :file => 'FILE'),
  :file_not_found        => Pwm::ErrorMessage.new('Store file <%= file %> could not be found.', 5, :file => 'FILE'),
  :key_blank             => Pwm::ErrorMessage.new('Name may not be blank.', 6),
  :value_blank           => Pwm::ErrorMessage.new('Value may not be blank.', 7),
  :list_empty            => Pwm::Message.new('List is empty.', 8),
  :list_empty_filter     => Pwm::Message.new('No names found that match filter <%= filter %>.', 9, :filter => 'FILTER'),
  :validation_new_failed => Pwm::ErrorMessage.new('<%= message %>.', 11, :message => 'REASON'),
}

program :help, 'Exit Status', "#{program(:name)} sets the following exit status:\n\n" + EXIT_CODES.values.sort{|l,r| l.exit_code <=> r.exit_code}.collect{|m| "      #{m.exit_code.to_s}: #{m.to_s}"}.join("\n")

program :help, 'Author', 'Nicholas E. Rabenau <nerab@gmx.at>'

DEFAULT_STORE_FILE = File.expand_path("~/.#{program(:name)}.pstore")
store_file = DEFAULT_STORE_FILE

global_option '-V', '--verbose', 'Enable verbose output'
global_option('-f', '--file FILE', 'Determine the file that holds the store'){|file| store_file = file}
global_option '-g', '--gui', 'Request the master password using an OS-specific GUI dialog'

command :init do |c|
  c.syntax = "#{program(:name)} init"
  c.summary = 'Initializes a new store'
  c.description = 'This command initializes a new password store. Password quality is enforced using validation rules.'
  c.example "Initializes a new password store in #{DEFAULT_STORE_FILE}", "#{program(:name)} #{c.name}"
  c.example "Initializes a new password store in /tmp/crackme.txt", "#{program(:name)} #{c.name} --file /tmp/crackme.txt"
  c.option '--force', 'Force-overwrite an existing store file'
  c.action do |args, options|
    # Store checks this too, but we want to fail fast.
    exit_with(:file_exists, options.verbose, :file => store_file) if File.exists?(store_file) && !options.force

    begin
      begin
        master_password = get_password('Enter new master password:', options.gui)
      end while begin
        validate!(master_password) # Basic idea from http://stackoverflow.com/questions/136793/is-there-a-do-while-loop-in-ruby
      rescue Pwm::InvalidMasterPasswordError => e
        STDERR.puts e.message # TODO Show GUI error message if options.gui
        options.gui || STDIN.tty? # only continue the loop when in interactive mode
      end

      # Ask for password confirmation if running in interactive mode (terminal)
      if STDIN.tty? && master_password != get_password('Enter master password again:', options.gui)
        exit_with(:passwords_dont_match, options.verbose)
      end
    rescue Pwm::Dialog::Cancelled
      exit_with(:aborted, options.verbose)
    end

    Pwm::Store.new(store_file, master_password, {:force => options.force})
    STDERR.puts "Successfully initialized new store at #{store_file}" if options.verbose
  end
end

command :get do |c|
  c.syntax = "#{program(:name)} get KEY"
  c.summary = 'Retrieves the value for KEY and prints it to STDOUT.'
  c.description = 'This command retrieves the value stored under KEY and prints it on STDOUT.'
  c.example 'Reads the value stored under the key "foo" and prints it to STDOUT', "#{program(:name)} #{c.name} foo"
  c.action do |args, options|
    # Store checks this too, but we want to fail fast and provide a message.
    exit_with(:file_not_found, options.verbose, :file => store_file) unless File.exists?(store_file)
    exit_with(:key_blank, options.verbose) if 0 == args.size || args[0].blank?

    begin
      result = Pwm::Store.open(store_file, get_password('Enter master password:', options.gui)).get(args[0])
      if result.blank?
        exit_with(:no_value_found, options.verbose, :key => args[0])
      else
        puts result
      end
    rescue Pwm::Dialog::Cancelled
      exit_with(:aborted, options.verbose)
    end
  end
end

command :list do |c|
  c.syntax = "#{program(:name)} list [FILTER]"
  c.summary = 'Lists all keys with optional FILTER.'
  c.description = 'This command prints all keys to STDOUT. If present, only those keys matching FILTER will be returned.'
  c.example 'Prints all keys', "#{program(:name)} #{c.name}"
  c.example 'Prints all keys which start with "foo"', "#{program(:name)} #{c.name} foo"
  c.example 'Prints all keys separated by comma', "#{program(:name)} #{c.name} --separator ,"
  c.option '-s', '--separator SEPARATOR', String, 'Separate keys by SEPARATOR'
  c.action do |args, options|
    # Store checks this too, but we want to fail fast and provide a message.
    exit_with(:file_not_found, options.verbose, :file => store_file) unless File.exists?(store_file)

    options.default :separator => ' '

    begin
      result = Pwm::Store.open(store_file, get_password('Enter master password:', options.gui)).list(args[0]).join(options.separator)
      if !result.blank?
        puts result
      else
        if args[0] # filter given
          exit_with(:list_empty_filter, options.verbose, args[0])
        else
          exit_with(:list_empty, options.verbose)
        end
      end
    rescue Pwm::Dialog::Cancelled
      exit_with(:aborted, options.verbose)
    end
  end
end

command :put do |c|
  c.syntax = "#{program(:name)} put KEY [VALUE]"
  c.summary = 'Stores VALUE under KEY'
  c.description = 'Adds or updates the entry stored under KEY. If KEY is already present in the store, it will be updated with VALUE. If KEY is not already present in the store, a new entry will be created. If VALUE is not given, it will be read from STDIN.'
  c.example 'Stores the value "bar" under the key "foo"', "#{program(:name)} #{c.name} foo bar"
  c.example 'Reads STDIN and stores that as value under the key "foo"', "#{program(:name)} #{c.name} foo"
  c.action do |args, options|
    exit_with(:file_not_found, options.verbose, :file => store_file) unless File.exists?(store_file)
    exit_with(:key_blank, options.verbose) if 0 == args.size || args[0].blank?

    # Ask for the master password _before_ it may be necessary to ask for the value in a terminal
    begin
      store = Pwm::Store.open(store_file, get_password('Enter master password:', options.gui))
    rescue Pwm::Dialog::Cancelled
      exit_with(:aborted, options.verbose)
    end

    value = args[1]

    if !value
      exit_with(:value_blank, options.verbose) unless STDIN.tty? || options.gui

      begin
        value = get_text("Enter value for key '#{args[0]}':", options.gui)
      rescue Pwm::Dialog::Cancelled
        exit_with(:aborted, options.verbose)
      end

      # still blank, even after asking for it?
      if value.blank?
        exit_with(:value_blank, true)
      end
    end

    store.put(args[0], value)
    STDERR.puts "Successfully stored new value under #{args[0]}." if options.verbose
  end
end

command :passwd do |c|
  c.syntax = "#{program(:name)} passwd [NEW_MASTER_PASSWORD]"
  c.summary = 'Changes the master password to NEW_MASTER_PASSWORD.'
  c.description = 'This command changes the master password of the store. Password quality is enforced using validation rules.'
  c.action do |args, options|
    exit_with(:file_not_found, options.verbose, :file => store_file) unless File.exists?(store_file)

    begin
      store = Pwm::Store.open(store_file, get_password('Enter current master password:', options.gui))

      if !STDIN.tty? && !options.gui
        # If we are in a pipe and do not run in GUI mode, we accept the new master password as args[0]
        new_master_password = args[0]

        begin
          validate!(new_master_password)
        rescue StandardError => e
          exit_with(:validation_new_failed, options.verbose, :message => e.message)
        end
      else
        # If running interactively (console or gui), we loop until we get a valid password or break
        begin
          new_master_password = get_password('Enter new master password:', options.gui)
        end while begin
          validate!(new_master_password)
        rescue Pwm::InvalidMasterPasswordError => e
          STDERR.puts e.message # TODO Show GUI error message if options.gui
          options.gui || STDIN.tty? # only continue the loop when in interactive mode
        end

        # Confirm new password
        if STDIN.tty? && new_master_password != get_password('Enter new master password again:', options.gui)
          exit_with(:passwords_dont_match, options.verbose)
        end
      end
    rescue Pwm::Dialog::Cancelled
      exit_with(:aborted, options.verbose)
    end

    store.change_password!(new_master_password)
    STDERR.puts "Successfully changed master password." if options.verbose
  end
end

def exit_with(error_code, verbose, msg_args = {})
  msg = EXIT_CODES[error_code]
  raise "No message defined for error #{error_code}" if !msg

  if msg.error? || verbose # always print errors; messages only when verbose
    STDERR.puts msg.to_s(msg_args)
  end

  exit(msg.exit_code)
end

def get_password(prompt, gui = false)
  (gui ? Pwm::Dialog::Password.new(program(:name), prompt) : Pwm::Dialog::ConsolePasswordDialog.new(prompt)).get_input
end

def get_text(prompt, gui = false)
  (gui ? Pwm::Dialog::Text.new(program(:name), prompt) : Pwm::Dialog::ConsoleTextDialog.new(prompt)).get_input
end

def validate!(pwd)
  Pwm::Store.password_policy.validate!(pwd)
end
